/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Applifting Blog Engine
 * This OpenAPI specification describes APIs available in the Applifing Blog Engine application.

**Following APIs are exposed:**
- Authentication - This API is used for login and access token acquisition
- Blog - This API is a CRUD over blog entries
- Comments - This API is used for comment creation and voting
- Image - This API serves as an image store. It is assumed that images are uploaded during article creation.
- Multitenancy - This API allows multiple blog instances to be active in a single application.

**Authorization**

All APIs except the Multitenancy API, are protected using API-KEY Token, which has either been given to the candidate during the exercise introduction or the candidate can create it themselves using the Multitenancy API `POST /tenants` endpoint. If you were already given a token, please prefer  to use it instead of creating a new one.   API-KEY Token MUST be sent like so `X-API-KEY: my-x-api-key` in the HTTP header.

Comments, Blog and Images APIs are also protected using the Access Token acquired from the `/login` EndPoint. Access Token MUST be sent like so `Authorization: my-access-token` in the HTTP header.
 * OpenAPI spec version: 1.0.0
 */
import type {
  AccessToken,
  Article,
  ArticleDetail,
  Comment,
  ImageInfo,
  ListArticlesParams,
  PostImagesBody,
  PostLoginBody,
  Tenant
} from './models';

import { customAxiosInstance } from './client/client';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];


  /**
 * @summary Sign in into the application
 */
export const postLogin = (
    postLoginBody: PostLoginBody,
 options?: SecondParameter<typeof customAxiosInstance>,) => {
      return customAxiosInstance<AccessToken>(
      {url: `/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: postLoginBody
    },
      options);
    }
  
/**
 * @summary List of all articles
 */
export const listArticles = (
    params?: ListArticlesParams,
 options?: SecondParameter<typeof customAxiosInstance>,) => {
      return customAxiosInstance<Article[]>(
      {url: `/articles`, method: 'GET',
        params
    },
      options);
    }
  
/**
 * @summary Create an article
 */
export const createArticle = (
    articleDetail: NonReadonly<ArticleDetail>,
 options?: SecondParameter<typeof customAxiosInstance>,) => {
      return customAxiosInstance<ArticleDetail>(
      {url: `/articles`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: articleDetail
    },
      options);
    }
  
/**
 * @summary Article detail with content and comments
 */
export const getArticle = (
    articleId: string,
 options?: SecondParameter<typeof customAxiosInstance>,) => {
      return customAxiosInstance<ArticleDetail>(
      {url: `/articles/${articleId}`, method: 'GET'
    },
      options);
    }
  
/**
 * @summary Update article detail
 */
export const updateArticle = (
    articleId: string,
    articleDetail: NonReadonly<ArticleDetail>,
 options?: SecondParameter<typeof customAxiosInstance>,) => {
      return customAxiosInstance<ArticleDetail>(
      {url: `/articles/${articleId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: articleDetail
    },
      options);
    }
  
/**
 * @summary Delete article
 */
export const deleteArticle = (
    articleId: string,
 options?: SecondParameter<typeof customAxiosInstance>,) => {
      return customAxiosInstance<void>(
      {url: `/articles/${articleId}`, method: 'DELETE'
    },
      options);
    }
  
/**
 * @summary Create comment
 */
export const postComments = (
    comment: NonReadonly<Comment>,
 options?: SecondParameter<typeof customAxiosInstance>,) => {
      return customAxiosInstance<Comment>(
      {url: `/comments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: comment
    },
      options);
    }
  
/**
 * @summary Upvote comment
 */
export const postCommentsCommentIdVoteUp = (
    commentId: string,
 options?: SecondParameter<typeof customAxiosInstance>,) => {
      return customAxiosInstance<Comment>(
      {url: `/comments/${commentId}/vote/up`, method: 'POST'
    },
      options);
    }
  
/**
 * @summary Downvote comment
 */
export const postCommentsCommentIdVoteDown = (
    commentId: string,
 options?: SecondParameter<typeof customAxiosInstance>,) => {
      return customAxiosInstance<Comment>(
      {url: `/comments/${commentId}/vote/down`, method: 'POST'
    },
      options);
    }
  
/**
 * @summary Upload an image
 */
export const postImages = (
    postImagesBody: PostImagesBody,
 options?: SecondParameter<typeof customAxiosInstance>,) => {const formData = new FormData();
if(postImagesBody.image !== undefined) {
 postImagesBody.image.forEach(value => formData.append(`image`, value));
 }

      return customAxiosInstance<ImageInfo[]>(
      {url: `/images`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData
    },
      options);
    }
  
/**
 * @summary Download image
 */
export const getImagesImageId = (
    imageId: string,
 options?: SecondParameter<typeof customAxiosInstance>,) => {
      return customAxiosInstance<void>(
      {url: `/images/${imageId}`, method: 'GET'
    },
      options);
    }
  
/**
 * @summary Delete image
 */
export const deleteImagesImageId = (
    imageId: string,
 options?: SecondParameter<typeof customAxiosInstance>,) => {
      return customAxiosInstance<void>(
      {url: `/images/${imageId}`, method: 'DELETE'
    },
      options);
    }
  
/**
 * @summary Create tenant
 */
export const postTenants = (
    tenant: NonReadonly<Tenant>,
 options?: SecondParameter<typeof customAxiosInstance>,) => {
      return customAxiosInstance<Tenant>(
      {url: `/tenants`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tenant
    },
      options);
    }
  
/**
 * @summary Info for a specific tenant
 */
export const getTenantsTenantId = (
    tenantId: string,
 options?: SecondParameter<typeof customAxiosInstance>,) => {
      return customAxiosInstance<Tenant>(
      {url: `/tenants/${tenantId}`, method: 'GET'
    },
      options);
    }
  
export type PostLoginResult = NonNullable<Awaited<ReturnType<typeof postLogin>>>
export type ListArticlesResult = NonNullable<Awaited<ReturnType<typeof listArticles>>>
export type CreateArticleResult = NonNullable<Awaited<ReturnType<typeof createArticle>>>
export type GetArticleResult = NonNullable<Awaited<ReturnType<typeof getArticle>>>
export type UpdateArticleResult = NonNullable<Awaited<ReturnType<typeof updateArticle>>>
export type DeleteArticleResult = NonNullable<Awaited<ReturnType<typeof deleteArticle>>>
export type PostCommentsResult = NonNullable<Awaited<ReturnType<typeof postComments>>>
export type PostCommentsCommentIdVoteUpResult = NonNullable<Awaited<ReturnType<typeof postCommentsCommentIdVoteUp>>>
export type PostCommentsCommentIdVoteDownResult = NonNullable<Awaited<ReturnType<typeof postCommentsCommentIdVoteDown>>>
export type PostImagesResult = NonNullable<Awaited<ReturnType<typeof postImages>>>
export type GetImagesImageIdResult = NonNullable<Awaited<ReturnType<typeof getImagesImageId>>>
export type DeleteImagesImageIdResult = NonNullable<Awaited<ReturnType<typeof deleteImagesImageId>>>
export type PostTenantsResult = NonNullable<Awaited<ReturnType<typeof postTenants>>>
export type GetTenantsTenantIdResult = NonNullable<Awaited<ReturnType<typeof getTenantsTenantId>>>
